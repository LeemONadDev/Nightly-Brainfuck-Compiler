Запуск: py brainfuck_compiler.py [обязательно: путь к программе] [библиотека с lib функциями]
echo [str] 			        	выводит текст
move_r!							переместить указатель вправо на 1 клеточку
move_l! 						переместить указатель влево на 1 клеточку
movec_r [int]               	перемещает указатель на введенное количество клеток вправо
movec_l [int]               	перемещает указатель на введенное количество клеток влево
zero!                       	сбрасывает значение ячейки, на которую навелся указатель до 0
add [int]                   	добавляет значение ячейки на указанное значение
minus [int]                 	отнимает значение ячейки на указанное значение
bf_code [str]               	пользовательский код brainfuck (не учитывает сдвиги по ячейкам)
$comment                    	строка, которая имеет символ $ не учитывается, это комментарий
def_func [str] [str]        	создание функции, путем ввода кода brainfuck (не учитывает сдвиги по ячейкам), также можно вывести функц
func_call [str]             	вызов функции по имени
lib_func_call [str]         	вызов функции из библиотеки
func_dump_c_end!            	выводит все функции из словаря в конце компиляции (нужна для отладки)
pointer_pos_dump_c_end!     	выводит позицию указателя в конце компиляции (может быть не точным, т.к. некоторый действия компилятор не учитывает)
errors_dump_c_end_disable!      отключает вывод всех ошибок компиляции в конце (если они конечно есть)
lib_func_dump_c_end!            выводит все функции в конце компиляции из библиотеки
mov_end!                        перемещает указатель в конец (на 30000 ячеек) 


Функции bfclib.bfcl (std)
lib_func_call endl              перенос строки
lib_func_call interp_debug      вставляет в код знак #, в многих интерпритаторах brainfuck этот знак считается знаком отладки
lib_func_сall input             позволяет ввести значение в ячейку
lib_func_call zero              аналог команды zero!, обнуляет ячейку
lib_func_call mov_l				аналог команды move_l!
lib_func_call mov_r				аналог команды move_r!